
.. _program_listing_file_include_Interface_CompositeData.hpp:

Program Listing for File CompositeData.hpp
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_Interface_CompositeData.hpp>` (``include\Interface\CompositeData.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef __COMPOSITEDATA_HPP__
   #define __COMPOSITEDATA_HPP__
   
   #include <optional>
   #include <variant>
   #include <assert.h>
   #include "Config.hpp"
   #include "Implementation/AsciiHeader.hpp"
   #include "Implementation/BinaryHeader.hpp"
   #include "Implementation/BinaryMeasurementDefinitions.hpp"
   #include "Interface/Registers.hpp"
   
   
   namespace VN
   {
       class CompositeData
       {
           public:
           struct TimeGroup
           {
               #if (TIME_GROUP_ENABLE & TIME_TIMESTARTUP_BIT)
               std::optional<Time> timeStartup; 
               #endif
               #if (TIME_GROUP_ENABLE & TIME_TIMEGPS_BIT)
               std::optional<Time> timeGps; 
               #endif
               #if (TIME_GROUP_ENABLE & TIME_TIMEGPSTOW_BIT)
               std::optional<Time> timeGpsTow; 
               #endif
               #if (TIME_GROUP_ENABLE & TIME_TIMEGPSWEEK_BIT)
               std::optional<uint16_t> timeGpsWeek; 
               #endif
               #if (TIME_GROUP_ENABLE & TIME_TIMESYNCIN_BIT)
               std::optional<Time> timeSyncIn; 
               #endif
               #if (TIME_GROUP_ENABLE & TIME_TIMEGPSPPS_BIT)
               std::optional<Time> timeGpsPps; 
               #endif
               #if (TIME_GROUP_ENABLE & TIME_TIMEUTC_BIT)
               std::optional<TimeUtc> timeUtc; 
               #endif
               #if (TIME_GROUP_ENABLE & TIME_SYNCINCNT_BIT)
               std::optional<uint32_t> syncInCnt; 
               #endif
               #if (TIME_GROUP_ENABLE & TIME_SYNCOUTCNT_BIT)
               std::optional<uint32_t> syncOutCnt; 
               #endif
               #if (TIME_GROUP_ENABLE & TIME_TIMESTATUS_BIT)
               std::optional<TimeStatus> timeStatus; 
               #endif
           };
           
           struct ImuGroup
           {
               #if (IMU_GROUP_ENABLE & IMU_IMUSTATUS_BIT)
               std::optional<ImuStatus> imuStatus; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_UNCOMPMAG_BIT)
               std::optional<Vec3f> uncompMag; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_UNCOMPACCEL_BIT)
               std::optional<Vec3f> uncompAccel; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_UNCOMPGYRO_BIT)
               std::optional<Vec3f> uncompGyro; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_TEMPERATURE_BIT)
               std::optional<float> temperature; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_PRESSURE_BIT)
               std::optional<float> pressure; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_DELTATHETA_BIT)
               std::optional<DeltaTheta> deltaTheta; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_DELTAVEL_BIT)
               std::optional<Vec3f> deltaVel; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_MAG_BIT)
               std::optional<Vec3f> mag; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_ACCEL_BIT)
               std::optional<Vec3f> accel; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_ANGULARRATE_BIT)
               std::optional<Vec3f> angularRate; 
               #endif
               #if (IMU_GROUP_ENABLE & IMU_SENSSAT_BIT)
               std::optional<uint16_t> sensSat; 
               #endif
           };
           
           struct GnssGroup
           {
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1TIMEUTC_BIT)
               std::optional<TimeUtc> gnss1TimeUtc; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GPS1TOW_BIT)
               std::optional<Time> gps1Tow; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GPS1WEEK_BIT)
               std::optional<uint16_t> gps1Week; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1NUMSATS_BIT)
               std::optional<uint8_t> gnss1NumSats; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1FIX_BIT)
               std::optional<uint8_t> gnss1Fix; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1POSLLA_BIT)
               std::optional<Lla> gnss1PosLla; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1POSECEF_BIT)
               std::optional<Vec3d> gnss1PosEcef; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1VELNED_BIT)
               std::optional<Vec3f> gnss1VelNed; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1VELECEF_BIT)
               std::optional<Vec3f> gnss1VelEcef; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1POSUNCERTAINTY_BIT)
               std::optional<Vec3f> gnss1PosUncertainty; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1VELUNCERTAINTY_BIT)
               std::optional<float> gnss1VelUncertainty; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1TIMEUNCERTAINTY_BIT)
               std::optional<float> gnss1TimeUncertainty; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1TIMEINFO_BIT)
               std::optional<GnssTimeInfo> gnss1TimeInfo; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1DOP_BIT)
               std::optional<GnssDop> gnss1Dop; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1SATINFO_BIT)
               std::optional<GnssSatInfo> gnss1SatInfo; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1RAWMEAS_BIT)
               std::optional<GnssRawMeas> gnss1RawMeas; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1STATUS_BIT)
               std::optional<GnssStatus> gnss1Status; 
               #endif
               #if (GNSS_GROUP_ENABLE & GNSS_GNSS1ALTMSL_BIT)
               std::optional<double> gnss1AltMSL; 
               #endif
           };
           
           struct AttitudeGroup
           {
               #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_YPR_BIT)
               std::optional<Ypr> ypr; 
               #endif
               #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_QUATERNION_BIT)
               std::optional<Quat> quaternion; 
               #endif
               #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_DCM_BIT)
               std::optional<Mat3f> dcm; 
               #endif
               #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_MAGNED_BIT)
               std::optional<Vec3f> magNed; 
               #endif
               #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_ACCELNED_BIT)
               std::optional<Vec3f> accelNed; 
               #endif
               #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_LINBODYACC_BIT)
               std::optional<Vec3f> linBodyAcc; 
               #endif
               #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_LINACCELNED_BIT)
               std::optional<Vec3f> linAccelNed; 
               #endif
               #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_YPRU_BIT)
               std::optional<Vec3f> yprU; 
               #endif
               #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_HEAVE_BIT)
               std::optional<Vec3f> heave; 
               #endif
               #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_ATTU_BIT)
               std::optional<float> attU; 
               #endif
           };
           
           struct InsGroup
           {
               #if (INS_GROUP_ENABLE & INS_INSSTATUS_BIT)
               std::optional<InsStatus> insStatus; 
               #endif
               #if (INS_GROUP_ENABLE & INS_POSLLA_BIT)
               std::optional<Lla> posLla; 
               #endif
               #if (INS_GROUP_ENABLE & INS_POSECEF_BIT)
               std::optional<Vec3d> posEcef; 
               #endif
               #if (INS_GROUP_ENABLE & INS_VELBODY_BIT)
               std::optional<Vec3f> velBody; 
               #endif
               #if (INS_GROUP_ENABLE & INS_VELNED_BIT)
               std::optional<Vec3f> velNed; 
               #endif
               #if (INS_GROUP_ENABLE & INS_VELECEF_BIT)
               std::optional<Vec3f> velEcef; 
               #endif
               #if (INS_GROUP_ENABLE & INS_MAGECEF_BIT)
               std::optional<Vec3f> magEcef; 
               #endif
               #if (INS_GROUP_ENABLE & INS_ACCELECEF_BIT)
               std::optional<Vec3f> accelEcef; 
               #endif
               #if (INS_GROUP_ENABLE & INS_LINACCELECEF_BIT)
               std::optional<Vec3f> linAccelEcef; 
               #endif
               #if (INS_GROUP_ENABLE & INS_POSU_BIT)
               std::optional<float> posU; 
               #endif
               #if (INS_GROUP_ENABLE & INS_VELU_BIT)
               std::optional<float> velU; 
               #endif
           };
           
           struct Gnss2Group
           {
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2TIMEUTC_BIT)
               std::optional<TimeUtc> gnss2TimeUtc; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GPS2TOW_BIT)
               std::optional<Time> gps2Tow; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GPS2WEEK_BIT)
               std::optional<uint16_t> gps2Week; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2NUMSATS_BIT)
               std::optional<uint8_t> gnss2NumSats; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2FIX_BIT)
               std::optional<uint8_t> gnss2Fix; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2POSLLA_BIT)
               std::optional<Lla> gnss2PosLla; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2POSECEF_BIT)
               std::optional<Vec3d> gnss2PosEcef; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2VELNED_BIT)
               std::optional<Vec3f> gnss2VelNed; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2VELECEF_BIT)
               std::optional<Vec3f> gnss2VelEcef; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2POSUNCERTAINTY_BIT)
               std::optional<Vec3f> gnss2PosUncertainty; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2VELUNCERTAINTY_BIT)
               std::optional<float> gnss2VelUncertainty; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2TIMEUNCERTAINTY_BIT)
               std::optional<float> gnss2TimeUncertainty; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2TIMEINFO_BIT)
               std::optional<GnssTimeInfo> gnss2TimeInfo; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2DOP_BIT)
               std::optional<GnssDop> gnss2Dop; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2SATINFO_BIT)
               std::optional<GnssSatInfo> gnss2SatInfo; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2RAWMEAS_BIT)
               std::optional<GnssRawMeas> gnss2RawMeas; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2STATUS_BIT)
               std::optional<GnssStatus> gnss2Status; 
               #endif
               #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2ALTMSL_BIT)
               std::optional<double> gnss2AltMSL; 
               #endif
           };
           
           struct Gnss3Group
           {
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3TIMEUTC_BIT)
               std::optional<TimeUtc> gnss3TimeUtc; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GPS3TOW_BIT)
               std::optional<Time> gps3Tow; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GPS3WEEK_BIT)
               std::optional<uint16_t> gps3Week; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3NUMSATS_BIT)
               std::optional<uint8_t> gnss3NumSats; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3FIX_BIT)
               std::optional<uint8_t> gnss3Fix; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3POSLLA_BIT)
               std::optional<Lla> gnss3PosLla; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3POSECEF_BIT)
               std::optional<Vec3d> gnss3PosEcef; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3VELNED_BIT)
               std::optional<Vec3f> gnss3VelNed; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3VELECEF_BIT)
               std::optional<Vec3f> gnss3VelEcef; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3POSUNCERTAINTY_BIT)
               std::optional<Vec3f> gnss3PosUncertainty; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3VELUNCERTAINTY_BIT)
               std::optional<float> gnss3VelUncertainty; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3TIMEUNCERTAINTY_BIT)
               std::optional<float> gnss3TimeUncertainty; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3TIMEINFO_BIT)
               std::optional<GnssTimeInfo> gnss3TimeInfo; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3DOP_BIT)
               std::optional<GnssDop> gnss3Dop; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3SATINFO_BIT)
               std::optional<GnssSatInfo> gnss3SatInfo; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3RAWMEAS_BIT)
               std::optional<GnssRawMeas> gnss3RawMeas; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3STATUS_BIT)
               std::optional<GnssStatus> gnss3Status; 
               #endif
               #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3ALTMSL_BIT)
               std::optional<double> gnss3AltMSL; 
               #endif
           };
           
           CompositeData() {};
           
           CompositeData(AsciiHeader asciiHeader) : _asciiHeader(asciiHeader) {};
           
           CompositeData(BinaryHeader binaryHeader) : _binaryHeader(binaryHeader) {};
           
           bool matchesMessage(const AsciiHeader& asciiHeader) const noexcept
           {
               if (_asciiHeader.has_value())
               {
                   return asciiHeader == _asciiHeader;
               }
               else
               {
                   return false;
               }
           }
           
           bool matchesMessage(const BinaryHeader& binaryHeader) const noexcept
           {
               if (_binaryHeader.has_value())
               {
                   return binaryHeader == _binaryHeader;
               }
               else
               {
                   return false;
               }
           }
           
           bool matchesMessage(const Registers::System::BinaryOutput& binaryOutputRegister) const noexcept
           {
               return matchesMessage(binaryOutputRegister.toBinaryHeader());
           }
           
           std::variant<AsciiHeader, BinaryHeader> header() const noexcept
           {
               if (_asciiHeader.has_value()) 
               {
                   return _asciiHeader.value();
               }
               else if (_binaryHeader.has_value()) 
               {
                   return _binaryHeader.value();
               }
               else 
               {
                   VN_ABORT();
               }
           }
           
           time_point timestamp;
           
           #if (TIME_GROUP_ENABLE)
           TimeGroup time;
           #endif
           #if (IMU_GROUP_ENABLE)
           ImuGroup imu;
           #endif
           #if (GNSS_GROUP_ENABLE)
           GnssGroup gnss;
           #endif
           #if (ATTITUDE_GROUP_ENABLE)
           AttitudeGroup attitude;
           #endif
           #if (INS_GROUP_ENABLE)
           InsGroup ins;
           #endif
           #if (GNSS2_GROUP_ENABLE)
           Gnss2Group gnss2;
           #endif
           #if (GNSS3_GROUP_ENABLE)
           Gnss3Group gnss3;
           #endif
           
           std::optional<uint32_t> asciiAppendCount;
           std::optional<uint16_t> asciiAppendStatus;
           
           template<class Extractor>
           bool copyFromBuffer(Extractor& extractor, const uint8_t measGroupIndex, const uint8_t measTypeIndex);
           
           private:
           std::optional<AsciiHeader> _asciiHeader = std::nullopt;
           std::optional<BinaryHeader> _binaryHeader = std::nullopt;
           
       }; // class CompositeData
       
       template<class Extractor>
       bool CompositeData::copyFromBuffer(Extractor& extractor, const uint8_t measGroupIndex, const uint8_t measTypeIndex)
       {
           switch (measGroupIndex)
           {
               case 0:
               {
                   switch (1 << measTypeIndex)
                   {
                       #if (TIME_GROUP_ENABLE & TIME_TIMESTARTUP_BIT)
                       case COMMON_TIMESTARTUP_BIT:
                       {
                           return extractor.extract(time.timeStartup);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_TIMEGPS_BIT)
                       case COMMON_TIMEGPS_BIT:
                       {
                           return extractor.extract(time.timeGps);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_TIMESYNCIN_BIT)
                       case COMMON_TIMESYNCIN_BIT:
                       {
                           return extractor.extract(time.timeSyncIn);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_YPR_BIT)
                       case COMMON_YPR_BIT:
                       {
                           return extractor.extract(attitude.ypr);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_QUATERNION_BIT)
                       case COMMON_QUATERNION_BIT:
                       {
                           return extractor.extract(attitude.quaternion);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_ANGULARRATE_BIT)
                       case COMMON_ANGULARRATE_BIT:
                       {
                           return extractor.extract(imu.angularRate);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_POSLLA_BIT)
                       case COMMON_POSLLA_BIT:
                       {
                           return extractor.extract(ins.posLla);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_VELNED_BIT)
                       case COMMON_VELNED_BIT:
                       {
                           return extractor.extract(ins.velNed);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_ACCEL_BIT)
                       case COMMON_ACCEL_BIT:
                       {
                           return extractor.extract(imu.accel);
                       }
                       #endif
                       
                       #if ((IMU_GROUP_ENABLE & IMU_UNCOMPACCEL_BIT) && (IMU_GROUP_ENABLE & IMU_UNCOMPGYRO_BIT))
                       case COMMON_IMU_BIT:
                       {
                           return !(!extractor.extract(imu.uncompAccel) && !extractor.extract(imu.uncompGyro));
                       }
                       #endif
                       
                       #if ((IMU_GROUP_ENABLE & IMU_MAG_BIT) && (IMU_GROUP_ENABLE & IMU_PRESSURE_BIT) && (IMU_GROUP_ENABLE & IMU_TEMPERATURE_BIT) )
                       case COMMON_MAGPRES_BIT:
                       {
                           return !(!extractor.extract(imu.mag) && !extractor.extract(imu.temperature) && !extractor.extract(imu.pressure));
                       }
                       #endif
                       
                       #if ((IMU_GROUP_ENABLE & IMU_DELTATHETA_BIT) && (IMU_GROUP_ENABLE & IMU_DELTAVEL_BIT))
                       case COMMON_DELTAS_BIT:
                       {
                           return !(!extractor.extract(imu.deltaTheta) && !extractor.extract(imu.deltaVel));
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_INSSTATUS_BIT)
                       case COMMON_INSSTATUS_BIT:
                       {
                           return extractor.extract(ins.insStatus);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_SYNCINCNT_BIT)
                       case COMMON_SYNCINCNT_BIT:
                       {
                           return extractor.extract(time.syncInCnt);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_TIMEGPSPPS_BIT)
                       case COMMON_TIMEGPSPPS_BIT:
                       {
                           return extractor.extract(time.timeGpsPps);
                       }
                       #endif
                       
                       default:
                       {
                           return true;
                       }
                   } // case 0:
               } // switch (measGroupIndex)
               
               case 1:
               {
                   switch (1 << measTypeIndex)
                   {
                       #if (TIME_GROUP_ENABLE & TIME_TIMESTARTUP_BIT)
                       case TIME_TIMESTARTUP_BIT:
                       {
                           return extractor.extract(time.timeStartup);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_TIMEGPS_BIT)
                       case TIME_TIMEGPS_BIT:
                       {
                           return extractor.extract(time.timeGps);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_TIMEGPSTOW_BIT)
                       case TIME_TIMEGPSTOW_BIT:
                       {
                           return extractor.extract(time.timeGpsTow);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_TIMEGPSWEEK_BIT)
                       case TIME_TIMEGPSWEEK_BIT:
                       {
                           return extractor.extract(time.timeGpsWeek);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_TIMESYNCIN_BIT)
                       case TIME_TIMESYNCIN_BIT:
                       {
                           return extractor.extract(time.timeSyncIn);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_TIMEGPSPPS_BIT)
                       case TIME_TIMEGPSPPS_BIT:
                       {
                           return extractor.extract(time.timeGpsPps);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_TIMEUTC_BIT)
                       case TIME_TIMEUTC_BIT:
                       {
                           return extractor.extract(time.timeUtc);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_SYNCINCNT_BIT)
                       case TIME_SYNCINCNT_BIT:
                       {
                           return extractor.extract(time.syncInCnt);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_SYNCOUTCNT_BIT)
                       case TIME_SYNCOUTCNT_BIT:
                       {
                           return extractor.extract(time.syncOutCnt);
                       }
                       #endif
                       
                       #if (TIME_GROUP_ENABLE & TIME_TIMESTATUS_BIT)
                       case TIME_TIMESTATUS_BIT:
                       {
                           return extractor.extract(time.timeStatus);
                       }
                       #endif
                       
                       default:
                       {
                           return true;
                       }
                   } // switch (1 << measTypeIndex)
                   break;
               } // case 1:
               
               case 2:
               {
                   switch (1 << measTypeIndex)
                   {
                       #if (IMU_GROUP_ENABLE & IMU_IMUSTATUS_BIT)
                       case IMU_IMUSTATUS_BIT:
                       {
                           return extractor.extract(imu.imuStatus);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_UNCOMPMAG_BIT)
                       case IMU_UNCOMPMAG_BIT:
                       {
                           return extractor.extract(imu.uncompMag);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_UNCOMPACCEL_BIT)
                       case IMU_UNCOMPACCEL_BIT:
                       {
                           return extractor.extract(imu.uncompAccel);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_UNCOMPGYRO_BIT)
                       case IMU_UNCOMPGYRO_BIT:
                       {
                           return extractor.extract(imu.uncompGyro);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_TEMPERATURE_BIT)
                       case IMU_TEMPERATURE_BIT:
                       {
                           return extractor.extract(imu.temperature);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_PRESSURE_BIT)
                       case IMU_PRESSURE_BIT:
                       {
                           return extractor.extract(imu.pressure);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_DELTATHETA_BIT)
                       case IMU_DELTATHETA_BIT:
                       {
                           return extractor.extract(imu.deltaTheta);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_DELTAVEL_BIT)
                       case IMU_DELTAVEL_BIT:
                       {
                           return extractor.extract(imu.deltaVel);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_MAG_BIT)
                       case IMU_MAG_BIT:
                       {
                           return extractor.extract(imu.mag);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_ACCEL_BIT)
                       case IMU_ACCEL_BIT:
                       {
                           return extractor.extract(imu.accel);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_ANGULARRATE_BIT)
                       case IMU_ANGULARRATE_BIT:
                       {
                           return extractor.extract(imu.angularRate);
                       }
                       #endif
                       
                       #if (IMU_GROUP_ENABLE & IMU_SENSSAT_BIT)
                       case IMU_SENSSAT_BIT:
                       {
                           return extractor.extract(imu.sensSat);
                       }
                       #endif
                       
                       default:
                       {
                           return true;
                       }
                   } // switch (1 << measTypeIndex)
                   break;
               } // case 2:
               
               case 3:
               {
                   switch (1 << measTypeIndex)
                   {
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1TIMEUTC_BIT)
                       case GNSS_GNSS1TIMEUTC_BIT:
                       {
                           return extractor.extract(gnss.gnss1TimeUtc);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GPS1TOW_BIT)
                       case GNSS_GPS1TOW_BIT:
                       {
                           return extractor.extract(gnss.gps1Tow);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GPS1WEEK_BIT)
                       case GNSS_GPS1WEEK_BIT:
                       {
                           return extractor.extract(gnss.gps1Week);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1NUMSATS_BIT)
                       case GNSS_GNSS1NUMSATS_BIT:
                       {
                           return extractor.extract(gnss.gnss1NumSats);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1FIX_BIT)
                       case GNSS_GNSS1FIX_BIT:
                       {
                           return extractor.extract(gnss.gnss1Fix);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1POSLLA_BIT)
                       case GNSS_GNSS1POSLLA_BIT:
                       {
                           return extractor.extract(gnss.gnss1PosLla);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1POSECEF_BIT)
                       case GNSS_GNSS1POSECEF_BIT:
                       {
                           return extractor.extract(gnss.gnss1PosEcef);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1VELNED_BIT)
                       case GNSS_GNSS1VELNED_BIT:
                       {
                           return extractor.extract(gnss.gnss1VelNed);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1VELECEF_BIT)
                       case GNSS_GNSS1VELECEF_BIT:
                       {
                           return extractor.extract(gnss.gnss1VelEcef);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1POSUNCERTAINTY_BIT)
                       case GNSS_GNSS1POSUNCERTAINTY_BIT:
                       {
                           return extractor.extract(gnss.gnss1PosUncertainty);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1VELUNCERTAINTY_BIT)
                       case GNSS_GNSS1VELUNCERTAINTY_BIT:
                       {
                           return extractor.extract(gnss.gnss1VelUncertainty);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1TIMEUNCERTAINTY_BIT)
                       case GNSS_GNSS1TIMEUNCERTAINTY_BIT:
                       {
                           return extractor.extract(gnss.gnss1TimeUncertainty);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1TIMEINFO_BIT)
                       case GNSS_GNSS1TIMEINFO_BIT:
                       {
                           return extractor.extract(gnss.gnss1TimeInfo);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1DOP_BIT)
                       case GNSS_GNSS1DOP_BIT:
                       {
                           return extractor.extract(gnss.gnss1Dop);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1SATINFO_BIT)
                       case GNSS_GNSS1SATINFO_BIT:
                       {
                           return extractor.extract(gnss.gnss1SatInfo);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1RAWMEAS_BIT)
                       case GNSS_GNSS1RAWMEAS_BIT:
                       {
                           return extractor.extract(gnss.gnss1RawMeas);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1STATUS_BIT)
                       case GNSS_GNSS1STATUS_BIT:
                       {
                           return extractor.extract(gnss.gnss1Status);
                       }
                       #endif
                       
                       #if (GNSS_GROUP_ENABLE & GNSS_GNSS1ALTMSL_BIT)
                       case GNSS_GNSS1ALTMSL_BIT:
                       {
                           return extractor.extract(gnss.gnss1AltMSL);
                       }
                       #endif
                       
                       default:
                       {
                           return true;
                       }
                   } // switch (1 << measTypeIndex)
                   break;
               } // case 3:
               
               case 4:
               {
                   switch (1 << measTypeIndex)
                   {
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_YPR_BIT)
                       case ATTITUDE_YPR_BIT:
                       {
                           return extractor.extract(attitude.ypr);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_QUATERNION_BIT)
                       case ATTITUDE_QUATERNION_BIT:
                       {
                           return extractor.extract(attitude.quaternion);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_DCM_BIT)
                       case ATTITUDE_DCM_BIT:
                       {
                           return extractor.extract(attitude.dcm);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_MAGNED_BIT)
                       case ATTITUDE_MAGNED_BIT:
                       {
                           return extractor.extract(attitude.magNed);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_ACCELNED_BIT)
                       case ATTITUDE_ACCELNED_BIT:
                       {
                           return extractor.extract(attitude.accelNed);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_LINBODYACC_BIT)
                       case ATTITUDE_LINBODYACC_BIT:
                       {
                           return extractor.extract(attitude.linBodyAcc);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_LINACCELNED_BIT)
                       case ATTITUDE_LINACCELNED_BIT:
                       {
                           return extractor.extract(attitude.linAccelNed);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_YPRU_BIT)
                       case ATTITUDE_YPRU_BIT:
                       {
                           return extractor.extract(attitude.yprU);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_HEAVE_BIT)
                       case ATTITUDE_HEAVE_BIT:
                       {
                           return extractor.extract(attitude.heave);
                       }
                       #endif
                       
                       #if (ATTITUDE_GROUP_ENABLE & ATTITUDE_ATTU_BIT)
                       case ATTITUDE_ATTU_BIT:
                       {
                           return extractor.extract(attitude.attU);
                       }
                       #endif
                       
                       default:
                       {
                           return true;
                       }
                   } // switch (1 << measTypeIndex)
                   break;
               } // case 4:
               
               case 5:
               {
                   switch (1 << measTypeIndex)
                   {
                       #if (INS_GROUP_ENABLE & INS_INSSTATUS_BIT)
                       case INS_INSSTATUS_BIT:
                       {
                           return extractor.extract(ins.insStatus);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_POSLLA_BIT)
                       case INS_POSLLA_BIT:
                       {
                           return extractor.extract(ins.posLla);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_POSECEF_BIT)
                       case INS_POSECEF_BIT:
                       {
                           return extractor.extract(ins.posEcef);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_VELBODY_BIT)
                       case INS_VELBODY_BIT:
                       {
                           return extractor.extract(ins.velBody);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_VELNED_BIT)
                       case INS_VELNED_BIT:
                       {
                           return extractor.extract(ins.velNed);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_VELECEF_BIT)
                       case INS_VELECEF_BIT:
                       {
                           return extractor.extract(ins.velEcef);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_MAGECEF_BIT)
                       case INS_MAGECEF_BIT:
                       {
                           return extractor.extract(ins.magEcef);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_ACCELECEF_BIT)
                       case INS_ACCELECEF_BIT:
                       {
                           return extractor.extract(ins.accelEcef);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_LINACCELECEF_BIT)
                       case INS_LINACCELECEF_BIT:
                       {
                           return extractor.extract(ins.linAccelEcef);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_POSU_BIT)
                       case INS_POSU_BIT:
                       {
                           return extractor.extract(ins.posU);
                       }
                       #endif
                       
                       #if (INS_GROUP_ENABLE & INS_VELU_BIT)
                       case INS_VELU_BIT:
                       {
                           return extractor.extract(ins.velU);
                       }
                       #endif
                       
                       default:
                       {
                           return true;
                       }
                   } // switch (1 << measTypeIndex)
                   break;
               } // case 5:
               
               case 6:
               {
                   switch (1 << measTypeIndex)
                   {
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2TIMEUTC_BIT)
                       case GNSS2_GNSS2TIMEUTC_BIT:
                       {
                           return extractor.extract(gnss2.gnss2TimeUtc);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GPS2TOW_BIT)
                       case GNSS2_GPS2TOW_BIT:
                       {
                           return extractor.extract(gnss2.gps2Tow);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GPS2WEEK_BIT)
                       case GNSS2_GPS2WEEK_BIT:
                       {
                           return extractor.extract(gnss2.gps2Week);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2NUMSATS_BIT)
                       case GNSS2_GNSS2NUMSATS_BIT:
                       {
                           return extractor.extract(gnss2.gnss2NumSats);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2FIX_BIT)
                       case GNSS2_GNSS2FIX_BIT:
                       {
                           return extractor.extract(gnss2.gnss2Fix);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2POSLLA_BIT)
                       case GNSS2_GNSS2POSLLA_BIT:
                       {
                           return extractor.extract(gnss2.gnss2PosLla);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2POSECEF_BIT)
                       case GNSS2_GNSS2POSECEF_BIT:
                       {
                           return extractor.extract(gnss2.gnss2PosEcef);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2VELNED_BIT)
                       case GNSS2_GNSS2VELNED_BIT:
                       {
                           return extractor.extract(gnss2.gnss2VelNed);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2VELECEF_BIT)
                       case GNSS2_GNSS2VELECEF_BIT:
                       {
                           return extractor.extract(gnss2.gnss2VelEcef);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2POSUNCERTAINTY_BIT)
                       case GNSS2_GNSS2POSUNCERTAINTY_BIT:
                       {
                           return extractor.extract(gnss2.gnss2PosUncertainty);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2VELUNCERTAINTY_BIT)
                       case GNSS2_GNSS2VELUNCERTAINTY_BIT:
                       {
                           return extractor.extract(gnss2.gnss2VelUncertainty);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2TIMEUNCERTAINTY_BIT)
                       case GNSS2_GNSS2TIMEUNCERTAINTY_BIT:
                       {
                           return extractor.extract(gnss2.gnss2TimeUncertainty);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2TIMEINFO_BIT)
                       case GNSS2_GNSS2TIMEINFO_BIT:
                       {
                           return extractor.extract(gnss2.gnss2TimeInfo);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2DOP_BIT)
                       case GNSS2_GNSS2DOP_BIT:
                       {
                           return extractor.extract(gnss2.gnss2Dop);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2SATINFO_BIT)
                       case GNSS2_GNSS2SATINFO_BIT:
                       {
                           return extractor.extract(gnss2.gnss2SatInfo);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2RAWMEAS_BIT)
                       case GNSS2_GNSS2RAWMEAS_BIT:
                       {
                           return extractor.extract(gnss2.gnss2RawMeas);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2STATUS_BIT)
                       case GNSS2_GNSS2STATUS_BIT:
                       {
                           return extractor.extract(gnss2.gnss2Status);
                       }
                       #endif
                       
                       #if (GNSS2_GROUP_ENABLE & GNSS2_GNSS2ALTMSL_BIT)
                       case GNSS2_GNSS2ALTMSL_BIT:
                       {
                           return extractor.extract(gnss2.gnss2AltMSL);
                       }
                       #endif
                       
                       default:
                       {
                           return true;
                       }
                   } // switch (1 << measTypeIndex)
                   break;
               } // case 6:
               
               case 12:
               {
                   switch (1 << measTypeIndex)
                   {
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3TIMEUTC_BIT)
                       case GNSS3_GNSS3TIMEUTC_BIT:
                       {
                           return extractor.extract(gnss3.gnss3TimeUtc);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GPS3TOW_BIT)
                       case GNSS3_GPS3TOW_BIT:
                       {
                           return extractor.extract(gnss3.gps3Tow);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GPS3WEEK_BIT)
                       case GNSS3_GPS3WEEK_BIT:
                       {
                           return extractor.extract(gnss3.gps3Week);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3NUMSATS_BIT)
                       case GNSS3_GNSS3NUMSATS_BIT:
                       {
                           return extractor.extract(gnss3.gnss3NumSats);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3FIX_BIT)
                       case GNSS3_GNSS3FIX_BIT:
                       {
                           return extractor.extract(gnss3.gnss3Fix);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3POSLLA_BIT)
                       case GNSS3_GNSS3POSLLA_BIT:
                       {
                           return extractor.extract(gnss3.gnss3PosLla);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3POSECEF_BIT)
                       case GNSS3_GNSS3POSECEF_BIT:
                       {
                           return extractor.extract(gnss3.gnss3PosEcef);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3VELNED_BIT)
                       case GNSS3_GNSS3VELNED_BIT:
                       {
                           return extractor.extract(gnss3.gnss3VelNed);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3VELECEF_BIT)
                       case GNSS3_GNSS3VELECEF_BIT:
                       {
                           return extractor.extract(gnss3.gnss3VelEcef);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3POSUNCERTAINTY_BIT)
                       case GNSS3_GNSS3POSUNCERTAINTY_BIT:
                       {
                           return extractor.extract(gnss3.gnss3PosUncertainty);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3VELUNCERTAINTY_BIT)
                       case GNSS3_GNSS3VELUNCERTAINTY_BIT:
                       {
                           return extractor.extract(gnss3.gnss3VelUncertainty);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3TIMEUNCERTAINTY_BIT)
                       case GNSS3_GNSS3TIMEUNCERTAINTY_BIT:
                       {
                           return extractor.extract(gnss3.gnss3TimeUncertainty);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3TIMEINFO_BIT)
                       case GNSS3_GNSS3TIMEINFO_BIT:
                       {
                           return extractor.extract(gnss3.gnss3TimeInfo);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3DOP_BIT)
                       case GNSS3_GNSS3DOP_BIT:
                       {
                           return extractor.extract(gnss3.gnss3Dop);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3SATINFO_BIT)
                       case GNSS3_GNSS3SATINFO_BIT:
                       {
                           return extractor.extract(gnss3.gnss3SatInfo);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3RAWMEAS_BIT)
                       case GNSS3_GNSS3RAWMEAS_BIT:
                       {
                           return extractor.extract(gnss3.gnss3RawMeas);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3STATUS_BIT)
                       case GNSS3_GNSS3STATUS_BIT:
                       {
                           return extractor.extract(gnss3.gnss3Status);
                       }
                       #endif
                       
                       #if (GNSS3_GROUP_ENABLE & GNSS3_GNSS3ALTMSL_BIT)
                       case GNSS3_GNSS3ALTMSL_BIT:
                       {
                           return extractor.extract(gnss3.gnss3AltMSL);
                       }
                       #endif
                       
                       default:
                       {
                           return true;
                       }
                   } // switch (1 << measTypeIndex)
                   break;
               } // case 12:
               
               
               default:
               {
                   return true;
               }
           } // switch (measGroupIndex)
           return true;
       } // CompositeData::copyFromBuffer
   } // namespace VN
   
   
   #endif //__COMPOSITEDATA_HPP__
   
   
